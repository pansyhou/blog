---
id: storage-system
slug: /storage-system
date: 2023-5-4
title: 存储系统
authors: pansyhou

---

[toc]

## 主存储器

可分为

- 随机读写RAM
- 只读ROM
- 高性能主存储器



### RAM

- SRAM
  - 使用双稳态触发器表示01
  - 常用作高速缓冲存储器Cache
- DRAM
  - 刷新间隔时间：DRAM最大信息保持时间，一般为2ms
  - 刷新方式：集中式刷新、分散式刷新、异步式刷新

#### DRAM集中式刷新

![image-20230504110507160](https://pic.imgdb.cn/item/645320e90d2dde5777307b54)

:::caution

注意死区时间的概念(为什么刷新时间是串行的？不应该是并行的吗？不过如果要写数据的话，可能真的要)

:::





#### 分布式刷新

大概是将一个存储周期分为访问和刷新，但是一个时钟周期有很多存储周期

优点是能够缩短刷新周期，死区减少

缺点应该就是这个刷新存储周期太多了

![image-20230504110935316](https://pic.imgdb.cn/item/645321fd0d2dde5777319617)

#### 异步刷新

我的评价是：降低分布式刷新的频率，取了折中的方法

![image-20230504111828243](https://pic.imgdb.cn/item/645324210d2dde577733a17e)

## 高速存储器

分为

- 双端口存储器
- 多体交叉存储器
- 相联存储器



### 双端口存储器

特点：同一个存储器具有`两组相互独立`的读写控制线路，允许两个独立的CPU**或控制器同时异步地访问存储单元**，是一种高速工作的存储器。其最大的特点是`存储数据共享`。
**结构特点**：具有`左右两个端口`，每一个端口都有自己的片选控制信号和输出使能控制信号。 

![image-20230504114910005](https://pic.imgdb.cn/item/64535b120d2dde57777fa7d8)

**访问冲突**：当左端口和右端口的地址`不相同`时，在两个端口上**同时进行读写操作，不会发生冲突**。若左、右端口**同时访问相同**的存储单元，则会**发生读写冲突**。

**解决方法**：判断逻辑决定对哪个端口优先进行读写操作，而**暂时关闭**另一个被延迟的端口，即置其忙信号**BUSY#=0**。

### 多体交叉存储器

:::caution

这个是普通的

:::

![image-20230504162010381](https://pic.imgdb.cn/item/64536abb0d2dde577795ef21)

:::caution

这个是交叉的

:::

![image-20230504162046270](https://pic.imgdb.cn/item/64536ae50d2dde5777961b33)

> 你要说有什么本质的区别吧?你看普通的，会发现他是地址是连续地在连续内存块上，而交叉的，并不是一种完全连续的，是有映射关系的

访问：CPU快速送出的M个地址，只要他们分属于M个存储体，访问就不会冲突；由存储器控制部件控制它们**分时**使用数据总线进行信息传递。

适合采用流水线方式**并行存取**，虽然每个存储体的存储周期没变，但是当CPU连续访问一个字块时，可以大大提高存储器的带宽。

**结构特点**：多体交叉存储器由M个的存储体（或称存储模块）组成，每个存储体有相同的容量和存取速度，又有各自独立的地址寄存器、地址译码器、读写电路和驱动电路。

**编址方法**：交叉编址，即任何两个相邻地址的物理单元不属于同一个存储体，一般在相邻的存储体中；同一个存储体内的地址都是不连续的。

:::info

**特点**：**通过改进主存的组织方式，在不改变存储器存取周期的情况下，提高存储器的带宽。**

:::

![image-20230504165927843](https://pic.imgdb.cn/item/645373f00d2dde5777a58b89)

:::info

为什么会快？如果处理器一下子要四个地址，刚好四个地址因为交叉的原因可以访问到四个存储体，刚好就可以并行访问，从而提高存储器的带宽。

:::

#### 例题

![image-20230504170152454](https://pic.imgdb.cn/item/645374800d2dde5777a6b210)

（好久没计算过带宽了捏，理论上是单位时间内的信息传输量？）

存取周期$T=200ns$ 总线传送周期$τ=50ns$

- **连续**读N个字的信息量是$q=N*64bit$（如果不是连续，那可能就不成立了，就是1 * 64）

- 读的时间是$t_{1}=T+(N-1)* τ$（即`存取周期`+`全部的总线传输周期`）

- 带宽$W_{1}=q / t_{1}$ （即信息量/时间）

  

![image-20230504171433097](https://pic.imgdb.cn/item/645377790d2dde5777aacdca)

### 相联存储器

**特点**：按`内容访问`的存储器，即在相联存储器中，一个字是通过它的部分内容而不是它的地址进行检索的。

:::tip

适用于快速查询的场合。

:::

![image-20230504215316697](https://pic.imgdb.cn/item/6453b8d20d2dde5777150e90)

看懂了

> 1. 先看最上面的01xx，这是最开始的东西
> 2. 下面是屏蔽寄存器，和32的寄存器很像的，只有置1的被取了出来
> 3. 再看右下角，是0100，因为屏蔽寄存器只需要最高的两位，即01，下面的全部置0，就变成了0100，如果第一步的01xx变成了1101，则右下角的变成了1100(因为屏蔽寄存器只要前两位，前两位跟着最初的数值)
> 4. 然后那一行被置1了，则代码寄存器输出的是0111那一行

:::tips

不懂可以看Netceor老哥的解释https://blog.csdn.net/Netceor/article/details/108900925

:::

### 提高存储速度的途径

1. 提高主存读写速度，或加长存储器的字长，加长一次读写数据宽度。
2. 采用并行操作的多端口存储器。
3. 采用多体交叉存储器，对多个存储体流水式并行存取数据，在每个存储周期，存取几个字。
4. 在CPU和主存之间加入高速缓冲Cache(后续学习)。

## 高速缓冲存储器Cache

![image-20230504220711970](https://pic.imgdb.cn/item/6453bc100d2dde577719f97e)

### Cache原理

![image-20230504221354515](https://pic.imgdb.cn/item/6453be870d2dde57771cafae)

### Cache读写操作

CPU在读写存储器时，Cache控制逻辑首先要**依据主存地址**来判断这个字是**否在Cache中**，若在Cache中，则称为“命中”；若不在，则称为“不命中”。针对命中/不命中、读/写操作，Cache的处理是不同的。

![image-20230504222017032](https://pic.imgdb.cn/item/6453bf210d2dde57771d643a)

### Cache读写的命中率、效率

> CPU执行一段程序时
>
> **cache**完成存取的次数为1900次
>
> **主存**完成存取的次数为100次
>
> 已知cache存取周期为50ns，主存存取周期为250ns
>
> 求: cache命中率**h**是多少?
>
> cache/主存系统平均访问时间$T_{a}$和效率e。

- **命中率 **$h=N_{c}/(N_{c}+N_{m})=1900/(1900+100)=0.95$
- **主存系统平均访问时间** $T_{a}=h·t_{c}+(1-h)·t_{m}=60ns$（Cache命中率 x Cache存取周期+主存命中率 x 主存存取周期）
- $效率=t_{c}/t_{a}=50/60=0.8333$(cache平均访问时间/主存平均访问时间)

### 主存与Cache的地址映射方式

CPU根据主存地址，判断Cache中，有没有这个主存该地址的备份数据，以便执行读写。

主存和Cache有三种地址映射方式：

1. 直接映射
2. 全相联映射
3. 组相联映射

#### 直接映像

![image-20230504224248707](https://pic.imgdb.cn/item/6453c4690d2dde57772499fa)

![image-20230504224728079](https://pic.imgdb.cn/item/6453c5810d2dde5777262be1)

主存块长=Cache块长(11位地址)

上例中，主存有2048块,Cache有m=16行(块),每块512B

![image-20230504225024527](https://pic.imgdb.cn/item/6453c6300d2dde577727794d)

> 如何根据CPU给出主存地址，判断Cache能否命中？

![image-20230504230741887](https://pic.imgdb.cn/item/6453ca3e0d2dde57772d118a)

取出主存11地址中的低4位地址，即Cache块(行)号，找到Cache行(块)，检查Cache的7位标记是否和主存高7位地址（组号)标记一致？一致命中!

#### 直接映像的地址变换方法

![image-20230504231232803](https://pic.imgdb.cn/item/6453cb610d2dde57772e78a5)
